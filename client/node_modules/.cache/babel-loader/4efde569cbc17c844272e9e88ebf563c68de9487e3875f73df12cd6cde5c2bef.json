{"ast":null,"code":"import ae from \"pino\";\nimport { RELAYER_DEFAULT_PROTOCOL as ce, RELAYER_EVENTS as F, EXPIRER_EVENTS as le, Store as z, Core as pe } from \"@walletconnect/core\";\nimport { getDefaultLoggerOptions as he, generateChildLogger as de, getLoggerContext as ge } from \"@walletconnect/logger\";\nimport { IEngine as me, ISignClient as we } from \"@walletconnect/types\";\nimport { TYPE_1 as ue, createDelayedPromise as v, engineEvent as p, getInternalError as c, calcExpiry as _, isValidObject as j, getRequiredNamespacesFromNamespaces as ye, getSdkError as R, isSessionCompatible as Se, isExpired as f, isValidParams as y, isUndefined as D, isValidRelays as Ee, isValidRequiredNamespaces as Ie, isValidNamespaces as Y, isConformingNamespaces as B, isValidString as A, isValidErrorReason as _e, isValidRelay as Re, isValidController as Ne, isValidNamespacesChainId as Q, isValidRequest as qe, isValidNamespacesRequest as Pe, isValidRequestExpiry as ve, isValidResponse as fe, isValidEvent as Oe, isValidNamespacesEvent as Ve, parseExpirerTarget as Te, isValidId as xe, getAppMetadata as De } from \"@walletconnect/utils\";\nimport Ae, { EventEmitter as be } from \"events\";\nimport { THIRTY_DAYS as Le, SEVEN_DAYS as W, FIVE_MINUTES as w, ONE_DAY as O, THIRTY_SECONDS as Z } from \"@walletconnect/time\";\nimport { isJsonRpcResult as N, isJsonRpcError as q, formatJsonRpcRequest as Ce, formatJsonRpcResult as Ge, formatJsonRpcError as $e, isJsonRpcRequest as Me, isJsonRpcResponse as Ue } from \"@walletconnect/jsonrpc-utils\";\nconst k = \"wc\",\n  X = 2,\n  J = \"client\",\n  C = `${k}@${X}:${J}:`,\n  G = {\n    name: J,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Ke = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  ze = {\n    database: \":memory:\"\n  },\n  je = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Ye = \"history\",\n  ke = \"0.3\",\n  ee = \"proposal\",\n  Xe = Le,\n  se = \"Proposal expired\",\n  te = \"session\",\n  b = W,\n  ie = \"engine\",\n  V = {\n    wc_sessionPropose: {\n      req: {\n        ttl: w,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: w,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: w,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: w,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: w,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: w,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: w,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: w,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: Z,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: Z,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  $ = {\n    min: w,\n    max: W\n  },\n  ne = \"request\";\nvar Je = Object.defineProperty,\n  He = Object.defineProperties,\n  Fe = Object.getOwnPropertyDescriptors,\n  oe = Object.getOwnPropertySymbols,\n  Be = Object.prototype.hasOwnProperty,\n  Qe = Object.prototype.propertyIsEnumerable,\n  re = (d, n, e) => n in d ? Je(d, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : d[n] = e,\n  u = (d, n) => {\n    for (var e in n || (n = {})) Be.call(n, e) && re(d, e, n[e]);\n    if (oe) for (var e of oe(n)) Qe.call(n, e) && re(d, e, n[e]);\n    return d;\n  },\n  H = (d, n) => He(d, Fe(n));\nclass We extends me {\n  constructor(n) {\n    var _this;\n    (super(n), _this = this), this.name = ie, this.events = new Ae(), this.initialized = !1, this.ignoredPayloadTypes = [ue], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({\n        methods: Object.keys(V)\n      }), this.initialized = !0);\n    }, this.connect = async e => {\n      this.isInitialized();\n      const s = H(u({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(s);\n      const {\n        pairingTopic: t,\n        requiredNamespaces: i,\n        optionalNamespaces: o,\n        sessionProperties: a,\n        relays: r\n      } = s;\n      let l = t,\n        h,\n        S = !1;\n      if (l && (S = this.client.core.pairing.pairings.get(l).active), !l || !S) {\n        const {\n          topic: I,\n          uri: g\n        } = await this.client.core.pairing.create();\n        l = I, h = g;\n      }\n      const m = await this.client.core.crypto.generateKeyPair(),\n        P = u({\n          requiredNamespaces: i,\n          optionalNamespaces: o,\n          relays: r ?? [{\n            protocol: ce\n          }],\n          proposer: {\n            publicKey: m,\n            metadata: this.client.metadata\n          }\n        }, a && {\n          sessionProperties: a\n        }),\n        {\n          reject: E,\n          resolve: T,\n          done: U\n        } = v(w, se);\n      if (this.events.once(p(\"session_connect\"), async _ref => {\n        let {\n          error: I,\n          session: g\n        } = _ref;\n        if (I) E(I);else if (g) {\n          g.self.publicKey = m;\n          const x = H(u({}, g), {\n            requiredNamespaces: g.requiredNamespaces,\n            optionalNamespaces: g.optionalNamespaces\n          });\n          await this.client.session.set(g.topic, x), await this.setExpiry(g.topic, g.expiry), l && (await this.client.core.pairing.updateMetadata({\n            topic: l,\n            metadata: g.peer.metadata\n          })), T(x);\n        }\n      }), !l) {\n        const {\n          message: I\n        } = c(\"NO_MATCHING_KEY\", `connect() pairing topic: ${l}`);\n        throw new Error(I);\n      }\n      const L = await this.sendRequest(l, \"wc_sessionPropose\", P),\n        K = _(w);\n      return await this.setProposal(L, u({\n        id: L,\n        expiry: K\n      }, P)), {\n        uri: h,\n        approval: U\n      };\n    }, this.pair = async e => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async e => {\n      this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: s,\n          relayProtocol: t,\n          namespaces: i,\n          sessionProperties: o\n        } = e,\n        a = this.client.proposal.get(s);\n      let {\n        pairingTopic: r,\n        proposer: l,\n        requiredNamespaces: h,\n        optionalNamespaces: S\n      } = a;\n      j(h) || (h = ye(i, \"approve()\"));\n      const m = await this.client.core.crypto.generateKeyPair(),\n        P = l.publicKey,\n        E = await this.client.core.crypto.generateSharedKey(m, P);\n      r && s && (await this.client.core.pairing.updateMetadata({\n        topic: r,\n        metadata: l.metadata\n      }), await this.sendResult(s, r, {\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        responderPublicKey: m\n      }), await this.client.proposal.delete(s, R(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: r\n      }));\n      const T = u({\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        namespaces: i,\n        requiredNamespaces: h,\n        optionalNamespaces: S,\n        controller: {\n          publicKey: m,\n          metadata: this.client.metadata\n        },\n        expiry: _(b)\n      }, o && {\n        sessionProperties: o\n      });\n      await this.client.core.relayer.subscribe(E);\n      const U = await this.sendRequest(E, \"wc_sessionSettle\", T),\n        {\n          done: L,\n          resolve: K,\n          reject: I\n        } = v();\n      this.events.once(p(\"session_approve\", U), _ref2 => {\n        let {\n          error: x\n        } = _ref2;\n        x ? I(x) : K(this.client.session.get(E));\n      });\n      const g = H(u({}, T), {\n        topic: E,\n        acknowledged: !1,\n        self: T.controller,\n        peer: {\n          publicKey: l.publicKey,\n          metadata: l.metadata\n        },\n        controller: m\n      });\n      return await this.client.session.set(E, g), await this.setExpiry(E, _(b)), {\n        topic: E,\n        acknowledged: L\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: s,\n          reason: t\n        } = e,\n        {\n          pairingTopic: i\n        } = this.client.proposal.get(s);\n      i && (await this.sendError(s, i, t), await this.client.proposal.delete(s, R(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: s,\n          namespaces: t\n        } = e,\n        i = await this.sendRequest(s, \"wc_sessionUpdate\", {\n          namespaces: t\n        }),\n        {\n          done: o,\n          resolve: a,\n          reject: r\n        } = v();\n      return this.events.once(p(\"session_update\", i), _ref3 => {\n        let {\n          error: l\n        } = _ref3;\n        l ? r(l) : a();\n      }), await this.client.session.update(s, {\n        namespaces: t\n      }), {\n        acknowledged: o\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: s\n        } = e,\n        t = await this.sendRequest(s, \"wc_sessionExtend\", {}),\n        {\n          done: i,\n          resolve: o,\n          reject: a\n        } = v();\n      return this.events.once(p(\"session_extend\", t), _ref4 => {\n        let {\n          error: r\n        } = _ref4;\n        r ? a(r) : o();\n      }), await this.setExpiry(s, _(b)), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: s,\n          request: t,\n          topic: i,\n          expiry: o\n        } = e,\n        a = await this.sendRequest(i, \"wc_sessionRequest\", {\n          request: t,\n          chainId: s\n        }, o),\n        {\n          done: r,\n          resolve: l,\n          reject: h\n        } = v(o);\n      return this.events.once(p(\"session_request\", a), _ref5 => {\n        let {\n          error: S,\n          result: m\n        } = _ref5;\n        S ? h(S) : l(m);\n      }), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: t,\n        chainId: s\n      }), await r();\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: s,\n          response: t\n        } = e,\n        {\n          id: i\n        } = t;\n      N(t) ? await this.sendResult(i, s, t.result) : q(t) && (await this.sendError(i, s, t.error)), this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      });\n    }, this.ping = async e => {\n      this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = await this.sendRequest(s, \"wc_sessionPing\", {}),\n          {\n            done: i,\n            resolve: o,\n            reject: a\n          } = v();\n        this.events.once(p(\"session_ping\", t), _ref6 => {\n          let {\n            error: r\n          } = _ref6;\n          r ? a(r) : o();\n        }), await i();\n      } else this.client.core.pairing.pairings.keys.includes(s) && (await this.client.core.pairing.ping({\n        topic: s\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.sendRequest(s, \"wc_sessionEvent\", {\n        event: t,\n        chainId: i\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: s\n      } = e;\n      this.client.session.keys.includes(s) ? (await this.sendRequest(s, \"wc_sessionDelete\", R(\"USER_DISCONNECTED\")), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({\n        topic: s\n      });\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => Se(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.deleteSession = async (e, s) => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), await Promise.all([this.client.session.delete(e, R(\"USER_DISCONNECTED\")), this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.deleteSymKey(e), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deleteProposal = async (e, s) => {\n      await Promise.all([this.client.proposal.delete(e, R(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deletePendingSessionRequest = async function (e, s) {\n      let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      await Promise.all([_this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : _this.client.core.expirer.del(e)]);\n    }, this.setExpiry = async (e, s) => {\n      this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: s\n      })), this.client.core.expirer.set(e, s);\n    }, this.setProposal = async (e, s) => {\n      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);\n    }, this.setPendingSessionRequest = async e => {\n      const s = V.wc_sessionRequest.req.ttl,\n        {\n          id: t,\n          topic: i,\n          params: o\n        } = e;\n      await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: i,\n        params: o\n      }), s && this.client.core.expirer.set(t, _(s));\n    }, this.sendRequest = async (e, s, t, i) => {\n      const o = Ce(s, t),\n        a = await this.client.core.crypto.encode(e, o),\n        r = V[s].req;\n      return i && (r.ttl = i), this.client.core.history.set(e, o), this.client.core.relayer.publish(e, a, r), o.id;\n    }, this.sendResult = async (e, s, t) => {\n      const i = Ge(e, t),\n        o = await this.client.core.crypto.encode(s, i),\n        a = await this.client.core.history.get(s, e),\n        r = V[a.request.method].res;\n      this.client.core.relayer.publish(s, o, r), await this.client.core.history.resolve(i);\n    }, this.sendError = async (e, s, t) => {\n      const i = $e(e, t),\n        o = await this.client.core.crypto.encode(s, i),\n        a = await this.client.core.history.get(s, e),\n        r = V[a.request.method].res;\n      this.client.core.relayer.publish(s, o, r), await this.client.core.history.resolve(i);\n    }, this.cleanup = async () => {\n      const e = [],\n        s = [];\n      this.client.session.getAll().forEach(t => {\n        f(t.expiry) && e.push(t.topic);\n      }), this.client.proposal.getAll().forEach(t => {\n        f(t.expiry) && s.push(t.id);\n      }), await Promise.all([...e.map(t => this.deleteSession(t)), ...s.map(t => this.deleteProposal(t))]);\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = (await this.client.core.history.get(s, t.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, t);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onSessionProposeRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidConnect(u({}, s.params));\n        const o = _(w),\n          a = u({\n            id: i,\n            pairingTopic: e,\n            expiry: o\n          }, t);\n        await this.setProposal(i, a), this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: a\n        });\n      } catch (o) {\n        await this.sendError(i, e, o), this.client.logger.error(o);\n      }\n    }, this.onSessionProposeResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      if (N(s)) {\n        const {\n          result: i\n        } = s;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const o = this.client.proposal.get(t);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: o\n        });\n        const a = o.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const r = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: r\n        });\n        const l = await this.client.core.crypto.generateSharedKey(a, r);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: l\n        });\n        const h = await this.client.core.relayer.subscribe(l);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else q(s) && (await this.client.proposal.delete(t, R(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_connect\"), {\n        error: s.error\n      }));\n    }, this.onSessionSettleRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: o,\n            controller: a,\n            expiry: r,\n            namespaces: l,\n            requiredNamespaces: h,\n            optionalNamespaces: S,\n            sessionProperties: m\n          } = s.params,\n          P = u({\n            topic: e,\n            relay: o,\n            expiry: r,\n            namespaces: l,\n            acknowledged: !0,\n            requiredNamespaces: h,\n            optionalNamespaces: S,\n            controller: a.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: a.publicKey,\n              metadata: a.metadata\n            }\n          }, m && {\n            sessionProperties: m\n          });\n        await this.sendResult(s.id, e, !0), this.events.emit(p(\"session_connect\"), {\n          session: P\n        });\n      } catch (o) {\n        await this.sendError(t, e, o), this.client.logger.error(o);\n      }\n    }, this.onSessionSettleResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(p(\"session_approve\", t), {})) : q(s) && (await this.client.session.delete(e, R(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_approve\", t), {\n        error: s.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidUpdate(u({\n          topic: e\n        }, t)), await this.client.session.update(e, {\n          namespaces: t.namespaces\n        }), await this.sendResult(i, e, !0), this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: t\n        });\n      } catch (o) {\n        await this.sendError(i, e, o), this.client.logger.error(o);\n      }\n    }, this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_update\", t), {}) : q(s) && this.events.emit(p(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, _(b)), await this.sendResult(t, e, !0), this.client.events.emit(\"session_extend\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_extend\", t), {}) : q(s) && this.events.emit(p(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(t, e, !0), this.client.events.emit(\"session_ping\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        N(s) ? this.events.emit(p(\"session_ping\", t), {}) : q(s) && this.events.emit(p(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: s.params\n        }), this.client.core.relayer.once(F.publish, async () => {\n          await this.deleteSession(e);\n        }), await this.sendResult(t, e, !0), this.client.events.emit(\"session_delete\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidRequest(u({\n          topic: e\n        }, i)), await this.setPendingSessionRequest({\n          id: t,\n          topic: e,\n          params: i\n        }), this.client.events.emit(\"session_request\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (o) {\n        await this.sendError(t, e, o), this.client.logger.error(o);\n      }\n    }, this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      N(s) ? this.events.emit(p(\"session_request\", t), {\n        result: s.result\n      }) : q(s) && this.events.emit(p(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidEmit(u({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (o) {\n        await this.sendError(t, e, o), this.client.logger.error(o);\n      }\n    }, this.isValidConnect = async e => {\n      if (!y(e)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(r);\n      }\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        optionalNamespaces: i,\n        sessionProperties: o,\n        relays: a\n      } = e;\n      if (D(s) || (await this.isValidPairingTopic(s)), !Ee(a, !0)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `connect() relays: ${a}`);\n        throw new Error(r);\n      }\n      !D(t) && j(t) !== 0 && this.validateNamespaces(t, \"requiredNamespaces\"), !D(i) && j(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), D(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.validateNamespaces = (e, s) => {\n      const t = Ie(e, \"connect()\", s);\n      if (t) throw new Error(t.message);\n    }, this.isValidApprove = async e => {\n      if (!y(e)) throw new Error(c(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: s,\n        namespaces: t,\n        relayProtocol: i,\n        sessionProperties: o\n      } = e;\n      await this.isValidProposalId(s);\n      const a = this.client.proposal.get(s),\n        r = Y(t, \"approve()\");\n      if (r) throw new Error(r.message);\n      const l = B(a.requiredNamespaces, t, \"approve()\");\n      if (l) throw new Error(l.message);\n      if (!A(i, !0)) {\n        const {\n          message: h\n        } = c(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      D(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!y(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: s,\n        reason: t\n      } = e;\n      if (await this.isValidProposalId(s), !_e(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!y(e)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: o\n      } = e;\n      if (!Re(s)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const a = Ne(t, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      const r = Y(i, \"onSessionSettleRequest()\");\n      if (r) throw new Error(r.message);\n      if (f(o)) {\n        const {\n          message: l\n        } = c(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!y(e)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        namespaces: t\n      } = e;\n      await this.isValidSessionTopic(s);\n      const i = this.client.session.get(s),\n        o = Y(t, \"update()\");\n      if (o) throw new Error(o.message);\n      const a = B(i.requiredNamespaces, t, \"update()\");\n      if (a) throw new Error(a.message);\n    }, this.isValidExtend = async e => {\n      if (!y(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async e => {\n      if (!y(e)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        request: t,\n        chainId: i,\n        expiry: o\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: a\n      } = this.client.session.get(s);\n      if (!Q(a, i)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(r);\n      }\n      if (!qe(t)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(t)}`);\n        throw new Error(r);\n      }\n      if (!Pe(a, i, t.method)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `request() method: ${t.method}`);\n        throw new Error(r);\n      }\n      if (o && !ve(o, $)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${$.min} and ${$.max}`);\n        throw new Error(r);\n      }\n    }, this.isValidRespond = async e => {\n      if (!y(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        topic: s,\n        response: t\n      } = e;\n      if (await this.isValidSessionTopic(s), !fe(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidPing = async e => {\n      if (!y(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async e => {\n      if (!y(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: o\n      } = this.client.session.get(s);\n      if (!Q(o, i)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!Oe(t)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      if (!Ve(o, i, t.name)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!y(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.validateSessionProps = (e, s) => {\n      Object.values(e).forEach(t => {\n        if (!A(t, !1)) {\n          const {\n            message: i\n          } = c(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);\n          throw new Error(i);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: n\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(n);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(F.message, async n => {\n      const {\n        topic: e,\n        message: s\n      } = n;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;\n      const t = await this.client.core.crypto.decode(e, s);\n      Me(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({\n        topic: e,\n        payload: t\n      })) : Ue(t) && (await this.client.core.history.resolve(t), this.onRelayEventResponse({\n        topic: e,\n        payload: t\n      }));\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(le.expired, async n => {\n      const {\n        topic: e,\n        id: s\n      } = Te(n.target);\n      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, c(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, !0), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", {\n        id: s\n      }));\n    });\n  }\n  isValidPairingTopic(n) {\n    if (!A(n, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (f(this.client.core.pairing.pairings.get(n).expiry)) {\n      const {\n        message: e\n      } = c(\"EXPIRED\", `pairing topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(n) {\n    if (!A(n, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (f(this.client.session.get(n).expiry)) {\n      await this.deleteSession(n);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `session topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(n) {\n    if (this.client.session.keys.includes(n)) await this.isValidSessionTopic(n);else if (this.client.core.pairing.pairings.keys.includes(n)) this.isValidPairingTopic(n);else if (A(n, !1)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(n) {\n    if (!xe(n)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `proposal id should be a number: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (f(this.client.proposal.get(n).expiry)) {\n      await this.deleteProposal(n);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `proposal id: ${n}`);\n      throw new Error(e);\n    }\n  }\n}\nclass Ze extends z {\n  constructor(n, e) {\n    super(n, e, ee, C), this.core = n, this.logger = e;\n  }\n}\nclass es extends z {\n  constructor(n, e) {\n    super(n, e, te, C), this.core = n, this.logger = e;\n  }\n}\nclass ss extends z {\n  constructor(n, e) {\n    super(n, e, ne, C), this.core = n, this.logger = e;\n  }\n}\nclass M extends we {\n  constructor(n) {\n    super(n), this.protocol = k, this.version = X, this.name = G.name, this.events = new be(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {\n      try {\n        return await this.engine.connect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.pair = async s => {\n      try {\n        return await this.engine.pair(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.approve = async s => {\n      try {\n        return await this.engine.approve(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.reject = async s => {\n      try {\n        return await this.engine.reject(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.update = async s => {\n      try {\n        return await this.engine.update(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.extend = async s => {\n      try {\n        return await this.engine.extend(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.request = async s => {\n      try {\n        return await this.engine.request(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.respond = async s => {\n      try {\n        return await this.engine.respond(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.ping = async s => {\n      try {\n        return await this.engine.ping(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.emit = async s => {\n      try {\n        return await this.engine.emit(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.disconnect = async s => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = n?.name || G.name, this.metadata = n?.metadata || De();\n    const e = typeof n?.logger < \"u\" && typeof n?.logger != \"string\" ? n.logger : ae(he({\n      level: n?.logger || G.logger\n    }));\n    this.core = n?.core || new pe(n), this.logger = de(e, this.name), this.session = new es(this.core, this.logger), this.proposal = new Ze(this.core, this.logger), this.pendingRequest = new ss(this.core, this.logger), this.engine = new We(this);\n  }\n  static async init(n) {\n    const e = new M(n);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return ge(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\");\n    } catch (n) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(n.message), n;\n    }\n  }\n}\nconst ts = M;\nexport { ie as ENGINE_CONTEXT, V as ENGINE_RPC_OPTS, Ye as HISTORY_CONTEXT, je as HISTORY_EVENTS, ke as HISTORY_STORAGE_VERSION, ee as PROPOSAL_CONTEXT, Xe as PROPOSAL_EXPIRY, se as PROPOSAL_EXPIRY_MESSAGE, ne as REQUEST_CONTEXT, te as SESSION_CONTEXT, b as SESSION_EXPIRY, $ as SESSION_REQUEST_EXPIRY_BOUNDARIES, J as SIGN_CLIENT_CONTEXT, G as SIGN_CLIENT_DEFAULT, Ke as SIGN_CLIENT_EVENTS, k as SIGN_CLIENT_PROTOCOL, ze as SIGN_CLIENT_STORAGE_OPTIONS, C as SIGN_CLIENT_STORAGE_PREFIX, X as SIGN_CLIENT_VERSION, ts as SignClient, M as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}